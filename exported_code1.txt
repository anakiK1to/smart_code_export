
=== src/App.tsx ===

import React from 'react';
import MainPage from './pages/MainPage';

const App: React.FC = () => (
  <div style={{ height: '100vh', width: '100vw' }}>
    <MainPage></MainPage>
  </div>
);

export default App;


=== src/vite-env.d.ts ===

/// <reference types="vite/client" />


=== src/main.tsx ===

import ReactDOM from 'react-dom/client';
import App from './App';
import { Provider } from 'react-redux';
import 'leaflet/dist/leaflet.css';
import { store } from './redux/store/Store';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <Provider store={store}>
    <App />
  </Provider>,
);


=== src/redux/store/Store.tsx ===

import { configureStore, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Device, Zone, DeviceType } from '../../types/devices';

type State = {
  devices: Device[];
  zones: Zone[];
  visibleTypes: Record<DeviceType, boolean>;
};

const initialState: State = {
  devices: [],
  zones: [],
  visibleTypes: { JAMMER: true, DETECTOR: true, SPOOFER: true },
};

const slice = createSlice({
  name: 'app',
  initialState,
  reducers: {
    setDevices: (s, a: PayloadAction<Device[]>) => {
      s.devices = a.payload;
    },
    setZones: (s, a: PayloadAction<Zone[]>) => {
      s.zones = a.payload;
    },
    toggleType: (s, a: PayloadAction<DeviceType>) => {
      s.visibleTypes[a.payload] = !s.visibleTypes[a.payload];
    },
  },
});

export const { setDevices, setZones, toggleType } = slice.actions;

export const store = configureStore({
  reducer: { app: slice.reducer },
});

export type RootState = ReturnType<typeof store.getState>;


=== src/redux/features/devices/deviceSlise.ts ===



=== src/redux/features/map/mapSlice.ts ===

import { createSlice } from '@reduxjs/toolkit';
import { MapBase } from '../../../types/map';

const initialState: MapBase = {
  mapType: 'osm',
  showGrid: false,
  zoom: 15,
  center: { lat: 59.956787, lng: 30.333947 },
  devices: [],
  zones: [],
  visibleTypes: { JAMMER: true, DETECTOR: true, SPOOFER: true },
  rulerMode: false,
};

const mapSlice = createSlice({
  name: 'map',
  initialState,
  reducers: {
    // toggleType: (s, a ) => { s.visibleTypes[a.payload] = !s.visibleTypes[a.payload] },
    // setDevices: (s, a) => {
    //   s.devices = a.payload;
    // },
    // setZones: (s, a) => {
    //   s.zones = a.payload;
    // },
    toggleMapType: (s) => {
      s.mapType = s.mapType === 'osm' ? 'google_satellite' : 'osm';
    },
    toggleRuler: (s) => {
      s.rulerMode = !s.rulerMode;
    },
    toggleGrid: (s) => {
      s.rulerMode = !s.rulerMode;
    },
    zoomIn: (s) => {
      s.zoom += 1;
    },
    zoomOut: (s) => {
      s.zoom -= 1;
    },
    setZoom: (s, a) => {
      s.zoom = a.payload;
    },
    setCenter: (s, a) => {
      s.center = a.payload;
    },
  },
});

export const {
  toggleMapType,
  toggleRuler,
  toggleGrid,
  zoomIn,
  zoomOut,
  setZoom,
  setCenter,
} = mapSlice.actions;
export default mapSlice.reducer;


=== src/mockData/deviceMockData.ts ===

import {
  Device,
  ConnectionStatus,
  OperationStatus,
  DeviceType,
  JammerType,
  ScanMode,
  SpoofingType,
} from '../types/devices';

const generateRandomCoordinates = (
  center: { lat: number; lng: number },
  radius: number,
) => {
  const y0 = center.lat;
  const x0 = center.lng;
  const rd = radius / 111300;

  const u = Math.random();
  const v = Math.random();

  const w = rd * Math.sqrt(u);
  const t = 2 * Math.PI * v;
  const x = w * Math.cos(t);
  const y = w * Math.sin(t);

  return {
    lat: y + y0,
    lng: x + x0,
  };
};

const centerMoscow = { lat: 55.751244, lng: 37.618423 };
const mockDevices: Device[] = [
  // Jammers
  {
    id: 'jammer-1',
    name: 'GSM Jammer Alpha',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.ONLINE,
    operationStatus: OperationStatus.ACTIVE,
    lastUpdated: new Date(Date.now() - 1000 * 60 * 2).toISOString(),
    batteryLevel: 78,
    isMobile: false,
    vendor: 'SignalShield Inc.',
    firmwareVersion: '2.4.1',
    type: DeviceType.JAMMER,
    jammerType: JammerType.GSM,
    frequencyRange: { min: 800, max: 2100 },
    jammingPower: 50,
    supportedProtocols: ['2G', '3G', '4G'],
    autoShutdownTimeout: 120,
    azimut: 45,
    sector: 60,
  },
  {
    id: 'jammer-2',
    name: 'UAV Jammer Mobile',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.UNSTABLE,
    operationStatus: OperationStatus.STANDBY,
    lastUpdated: new Date(Date.now() - 1000 * 60 * 15).toISOString(),
    batteryLevel: 92,
    isMobile: true,
    vendor: 'AntiDrone Systems',
    firmwareVersion: '1.7.3',
    type: DeviceType.JAMMER,
    jammerType: JammerType.UAV,
    frequencyRange: { min: 2400, max: 5800 },
    jammingPower: 120,
    supportedProtocols: ['DJI', 'Autel', 'Skydio'],
    autoShutdownTimeout: 180,
    azimut: 180,
    sector: 90,
  },

  // Detectors
  {
    id: 'detector-1',
    name: 'Spectrum Analyzer X7',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.ONLINE,
    operationStatus: OperationStatus.ACTIVE,
    lastUpdated: new Date(Date.now() - 1000 * 30).toISOString(),
    batteryLevel: 65,
    isMobile: true,
    vendor: 'RFScout',
    firmwareVersion: '3.0.2',
    type: DeviceType.DETECTOR,
    frequency: 2450,
    radius: { value: 2, unit: 'km' },
    sensitivity: -90,
    scanMode: ScanMode.DEEP,
    detectedSignals: [
      { frequency: 2412, strength: -45, type: 'WiFi' },
      { frequency: 2442, strength: -62, type: 'WiFi' },
      { frequency: 1575, strength: -38, type: 'GPS' },
    ],
  },
  {
    id: 'detector-2',
    name: 'Portable RF Monitor',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.ONLINE,
    operationStatus: OperationStatus.ACTIVE,
    lastUpdated: new Date().toISOString(),
    batteryLevel: 85,
    isMobile: true,
    vendor: 'WaveTrack',
    firmwareVersion: '1.2.0',
    type: DeviceType.DETECTOR,
    frequency: 900,
    radius: { value: 1.5, unit: 'km' },
    sensitivity: -85,
    scanMode: ScanMode.FAST,
    detectedSignals: [
      { frequency: 925, strength: -55, type: 'GSM' },
      { frequency: 868, strength: -72, type: 'LoRa' },
    ],
  },

  // Spoofers
  {
    id: 'spoofer-1',
    name: 'GPS Spoofer Phantom',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.ONLINE,
    operationStatus: OperationStatus.ACTIVE,
    lastUpdated: new Date(Date.now() - 1000 * 60 * 5).toISOString(),
    batteryLevel: 90,
    isMobile: false,
    vendor: 'NavGuard',
    firmwareVersion: '4.1.7',
    type: DeviceType.SPOOFER,
    transmitterPower: 200,
    effectRadius: { value: 3, unit: 'km' },
    spoofingType: SpoofingType.MEACONING,
    frequencyRanges: [
      { min: 1575, max: 1575.42 }, // GPS L1
      { min: 1227, max: 1227.6 }, // GPS L2
    ],
    activeScenario: 'Urban Navigation Disruption',
    successRate: 87,
  },
  {
    id: 'spoofer-2',
    name: 'Mobile Spoofer Unit',
    coordinates: generateRandomCoordinates(centerMoscow, 5000),
    connectionStatus: ConnectionStatus.UPDATING,
    operationStatus: OperationStatus.STANDBY,
    lastUpdated: new Date(Date.now() - 1000 * 60 * 10).toISOString(),
    batteryLevel: 45,
    isMobile: true,
    vendor: 'SignalForge',
    firmwareVersion: '2.9.0',
    type: DeviceType.SPOOFER,
    transmitterPower: 150,
    effectRadius: { value: 1.2, unit: 'km' },
    spoofingType: SpoofingType.GENERATIVE,
    frequencyRanges: [
      { min: 2400, max: 2483 }, // WiFi
      { min: 3400, max: 3800 }, // 5G
    ],
    activeScenario: 'WiFi Network Simulation',
    successRate: 92,
  },
];

export const getMockDevices = (count?: number): Device[] => {
  if (count) {
    return mockDevices.slice(0, count);
  }
  return mockDevices;
};

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:
// const devices = getMockDevices(); // –≤—Å–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
// const threeDevices = getMockDevices(3); // –ø–µ—Ä–≤—ã–µ 3 —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞


=== src/features/map/MapFeature.tsx ===

import React from 'react';
import { useSelector } from 'react-redux';
import DeviceMarker from '../../components/deviceMap/DeviceMarker';
import ZoneCircle from '../../components/deviceMap/ZoneCircle';
import { RootState } from '../../redux/store/Store';

const MapFeature: React.FC = () => {
  const { devices, zones, visibleTypes } = useSelector((s: RootState) => s.app);

  return (
    <>
      {zones.map((z) => (
        <ZoneCircle key={z.id} zone={z} />
      ))}
      {devices
        .filter((d) => visibleTypes[d.type])
        .map((d) => (
          <DeviceMarker key={d.id} device={d} />
        ))}
    </>
  );
};

export default MapFeature;


=== src/features/map/Map.tsx ===

import React, { useEffect } from 'react';
import { MapContainer, TileLayer } from 'react-leaflet';
import { useDispatch } from 'react-redux';
import MapFeature from './MapFeature';
import 'leaflet/dist/leaflet.css';
import { getMockDevices } from '../../mockData/deviceMockData';
import { setDevices } from '../../redux/store/Store';
import Toolbar from '../../components/toolbar/Toolbar';

const tileURL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';

const Map: React.FC = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setDevices(getMockDevices()));
  }, [dispatch]);

  return (
    <MapContainer
      center={[55.751, 37.618]}
      zoom={10}
      style={{ height: '100%', width: '100%' }}
    >
      <TileLayer url={tileURL} />
      <MapFeature />
      <Toolbar />
    </MapContainer>
  );
};

export default Map;


=== src/router/index.tsx ===



=== src/components/deviceMap/DeviceMarker.css ===

.device-marker {
  background: white;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  text-align: center;
  line-height: 24px;
  font-weight: bold;
}


=== src/components/deviceMap/DeviceMarker.tsx ===

import React from 'react';
import { Marker, Tooltip, Circle, Polygon } from 'react-leaflet';
import L from 'leaflet';
import {
  Device,
  Jammer,
  Detector,
  DeviceType,
  Spoofer,
} from '../../types/devices';

type Props = { device: Device };

const DeviceMarker: React.FC<Props> = ({ device }) => {
  const getBaseIcon = (color: string, letter: string) => {
    return new L.DivIcon({
      html: `
        <div style="
          width: 32px;
          height: 32px;
          background: ${color};
          border: 2px solid white;
          border-radius: 50%;
          display: flex;
          justify-content: center;
          align-items: center;
          color: white;
          font-weight: bold;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        ">
          ${letter}
        </div>
      `,
      className: '',
      iconSize: [32, 32],
      iconAnchor: [16, 16],
    });
  };

  const renderJammerComponents = (jammer: Jammer) => {
    const getSectorPoints = () => {
      const center = [jammer.coordinates.lat, jammer.coordinates.lng];
      const radius = jammer.jammingPower * 10;
      const startAngle = jammer.azimut - jammer.sector / 2;
      const endAngle = jammer.azimut + jammer.sector / 2;
      const points = [center];

      for (let angle = startAngle; angle <= endAngle; angle += 5) {
        const rad = (angle * Math.PI) / 180;
        const lat = center[0] + (radius / 111300) * Math.cos(rad);
        const lng =
          center[1] +
          (radius / (111300 * Math.cos((center[0] * Math.PI) / 180))) *
            Math.sin(rad);
        points.push([lat, lng]);
      }

      return points;
    };

    return (
      <>
        <Polygon
          positions={getSectorPoints()}
          color="red"
          fillColor="rgba(255, 0, 0, 0.2)"
          fillOpacity={0.5}
        />
      </>
    );
  };

  const renderDetectorComponents = (detector: Detector) => {
    const radiusInMeters =
      detector.radius.unit === 'km'
        ? detector.radius.value * 1000
        : detector.radius.value;

    return (
      <Circle
        center={[detector.coordinates.lat, detector.coordinates.lng]}
        radius={radiusInMeters}
        color="blue"
        fillColor="rgba(0, 0, 255, 0.2)"
        fillOpacity={0.5}
      />
    );
  };

  const renderSpooferComponents = (spoofer: Spoofer) => {
    const radiusInMeters =
      spoofer.effectRadius.unit === 'km'
        ? spoofer.effectRadius.value * 1000
        : spoofer.effectRadius.value;

    return (
      <>
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters * 0.3}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.3}
          stroke={true}
        />
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters * 0.6}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.2}
          stroke={true}
        />
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.1}
          stroke={true}
        />
      </>
    );
  };

  const renderDeviceSpecificComponents = () => {
    switch (device.type) {
      case DeviceType.JAMMER:
        return renderJammerComponents(device as Jammer);
      case DeviceType.DETECTOR:
        return renderDetectorComponents(device as Detector);
      case DeviceType.SPOOFER:
        return renderSpooferComponents(device as Spoofer);
      default:
        return null;
    }
  };

  const getDeviceIcon = () => {
    switch (device.type) {
      case DeviceType.JAMMER:
        return getBaseIcon('#ff4444', 'J');
      case DeviceType.DETECTOR:
        return getBaseIcon('#4444ff', 'D');
      case DeviceType.SPOOFER:
        return getBaseIcon('#cc00cc', 'S');
      default:
        return getBaseIcon('#888888', '?');
    }
  };

  const renderTooltipContent = () => {
    return (
      <div style={{ padding: '4px', fontSize: '12px' }}>
        <strong>{device.name}</strong>
        <br />
        –¢–∏–ø: {device.type}
        <br />
        –°—Ç–∞—Ç—É—Å:{' '}
        <span
          style={{
            color: device.connectionStatus === 'ONLINE' ? 'green' : 'red',
          }}
        >
          {device.connectionStatus}
        </span>
        <br />
        –ë–∞—Ç–∞—Ä–µ—è: {device.batteryLevel}%
      </div>
    );
  };

  return (
    <>
      <Marker
        position={[device.coordinates.lat, device.coordinates.lng]}
        icon={getDeviceIcon()}
      >
        <Tooltip direction="top" offset={[0, -16]} opacity={1}>
          {renderTooltipContent()}
        </Tooltip>
      </Marker>
      {renderDeviceSpecificComponents()}
    </>
  );
};

export default DeviceMarker;


=== src/components/deviceMap/deviceMapSlice.ts ===

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Device, DeviceGroup, Zone, DeviceType } from '../../types/devices';

interface DeviceMapState {
  devices: Device[];
  groups: DeviceGroup[];
  zones: Zone[];
  visibleTypes: Record<DeviceType, boolean>;
}

const initialState: DeviceMapState = {
  devices: [],
  groups: [],
  zones: [],
  visibleTypes: { JAMMER: true, DETECTOR: true, SPOOFER: true },
};

export const deviceMapSlice = createSlice({
  name: 'deviceMap',
  initialState,
  reducers: {
    setDevices: (s, a: PayloadAction<Device[]>) => {
      s.devices = a.payload;
    },
    setGroups: (s, a: PayloadAction<DeviceGroup[]>) => {
      s.groups = a.payload;
    },
    setZones: (s, a: PayloadAction<Zone[]>) => {
      s.zones = a.payload;
    },
    toggleTypeVisibility: (s, a: PayloadAction<DeviceType>) => {
      s.visibleTypes[a.payload] = !s.visibleTypes[a.payload];
    },
  },
});

export const { setDevices, setGroups, setZones, toggleTypeVisibility } =
  deviceMapSlice.actions;
export default deviceMapSlice.reducer;


=== src/components/deviceMap/SystemMenu.css ===

.system-menu {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 10px;
  max-height: 40vh;
  overflow-y: auto;
  border-radius: 6px;
  z-index: 1000;
}
.device-info {
  margin-bottom: 8px;
  font-size: 0.9rem;
  line-height: 1.2;
}
.device-info strong {
  font-size: 1rem;
}
.system-menu label {
  display: block;
  margin-bottom: 4px;
  cursor: pointer;
}
.system-menu hr {
  border: 0;
  border-top: 1px solid rgba(255, 255, 255, 0.3);
  margin: 8px 0;
}


=== src/components/deviceMap/SystemMenu.tsx ===

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import './SystemMenu.css';
import { toggleType } from '../../redux/store/Store';

const SystemMenu: React.FC = () => {
  const dispatch = useDispatch();
  const { devices, visibleTypes } = useSelector((s: RootState) => s.app);

  return (
    <div className="system-menu">
      <h3>–°–∏—Å—Ç–µ–º–∞</h3>
      {Object.keys(visibleTypes).map((type) => (
        <label key={type}>
          <input
            type="checkbox"
            checked={visibleTypes[type as any]}
            onChange={() => dispatch(toggleType(type as any))}
          />
          {type}
        </label>
      ))}
      <hr />
      {devices.map((d) => (
        <div key={d.id} className="device-info">
          <strong>{d.name}</strong> [{d.type}]
          <div>
            Status: {d.connectionStatus}, Battery: {d.batteryLevel}%
          </div>
          <div>
            Coords: {d.coordinates.lat.toFixed(5)},{' '}
            {d.coordinates.lng.toFixed(5)}
          </div>
        </div>
      ))}
    </div>
  );
};

export default SystemMenu;


=== src/components/deviceMap/ZoneCircle.tsx ===

import React from 'react';
import { Circle } from 'react-leaflet';
import { Zone } from '../../types/devices';

type Props = { zone: Zone };

const ZoneCircle: React.FC<Props> = ({ zone }) => (
  <Circle
    center={[zone.center.lat, zone.center.lng]}
    radius={zone.radius}
    pathOptions={{ color: 'blue', fillOpacity: 0.1 }}
  />
);

export default ZoneCircle;


=== src/components/deviceMap/DeviceRadiusRuler.tsx ===

// src/components/deviceMap/DeviceRadiusRuler.tsx

import { Circle } from 'react-leaflet';
import { Coordinates } from '../../types/devices';

type Props = {
  center: Coordinates;
  radius: number;
};

export const DeviceRadiusRuler: React.FC<Props> = ({ center, radius }) => (
  <Circle
    center={[center.lat, center.lng]}
    radius={radius}
    pathOptions={{ dashArray: '4', color: 'orange' }}
  />
);


=== src/components/toolbar/Toolbar.tsx ===

/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import './Toolbar.css';
import { useSelector, useDispatch } from 'react-redux';
import { toggleRuler, zoomIn } from '../../redux/features/map/mapSlice';
import { useMap } from 'react-leaflet';

const Toolbar: React.FC = () => {
  const map = useMap();
  const dispatch = useDispatch();
  const mapType = useSelector((s: any) => s.app.mapType);
  const ruler = useSelector((s: any) => s.app.rulerMode);

  return (
    <div className="toolbar">
      <button onClick={() => map.zoomIn()}>+</button>
      <button onClick={() => map.zoomOut()}>‚Äì</button>
      {/* <button onClick={() => map.setView(map.getCenter(), 10)}>üéØ</button> */}
      <button onClick={() => dispatch(zoomIn())}>
        {mapType === 'osm' ? '–°–∞—Ç—Ç–µ–ª–∏—Ç' : 'OSM'}
      </button>
      {/* <button onClick={() => dispatch(zoomIn())}</button> */}
      <button
        className={ruler ? 'active' : ''}
        onClick={() => dispatch(toggleRuler())}
      >
        üìè
      </button>
    </div>
  );
};
export default Toolbar;


=== src/components/toolbar/Toolbar.css ===

.toolbar {
  position: absolute;
  top: 50%;
  left: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 1000;
}
.toolbar button {
  width: 36px;
  height: 36px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
.toolbar button.active {
  background: rgba(255, 255, 255, 0.8);
  color: black;
}


=== src/components/gridOverlayComponent/gridSlice.ts ===

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface GridState {
  step: number;
  color: string;
}

const initialState: GridState = {
  step: 10,
  color: 'rgba(0, 0, 0, 0.5)',
};

const gridSlice = createSlice({
  name: 'grid',
  initialState,
  reducers: {
    setStep: (state, action: PayloadAction<number>) => {
      state.step = action.payload;
    },
    setColor: (state, action: PayloadAction<string>) => {
      state.color = action.payload;
    },
  },
});

export const { setStep, setColor } = gridSlice.actions;
export default gridSlice.reducer;


=== src/components/gridOverlayComponent/GridOverlay.tsx ===

import React, { useEffect, useRef } from 'react';
import { useMap } from 'react-leaflet';

const GridOverlay: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const map = useMap();

  useEffect(() => {
    if (!map || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const drawGrid = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillStyle = 'color';
      ctx.font = '12px Arial';

      const gridSize = 100;

      for (let x = 0; x < canvas.width; x += gridSize) {
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.rect(x, y, gridSize, gridSize);
          ctx.stroke();
        }
      }

      const topLeft = map.containerPointToLatLng([0, 0]);
      const bottomRight = map.containerPointToLatLng([
        canvas.width,
        canvas.height,
      ]);

      const latStep =
        (topLeft.lat - bottomRight.lat) / (canvas.height / gridSize);
      const lngStep =
        (bottomRight.lng - topLeft.lng) / (canvas.width / gridSize);

      for (let x = 0; x < canvas.width; x += gridSize) {
        const lng = topLeft.lng + (x / gridSize) * lngStep;
        ctx.fillText(lng.toFixed(2), x + 5, 15);
      }

      for (let y = 0; y < canvas.height; y += gridSize) {
        const lat = topLeft.lat - (y / gridSize) * latStep;
        ctx.fillText(lat.toFixed(2), 5, y - 5);
      }
    };

    map.on('move', drawGrid);
    map.on('zoom', drawGrid);
    drawGrid();

    return () => {
      map.off('move', drawGrid);
      map.off('zoom', drawGrid);
    };
  }, [map]);

  return (
    <canvas
      ref={canvasRef}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: 1000,
        pointerEvents: 'none',
      }}
    />
  );
};

export default GridOverlay;


=== src/pages/MainPage.tsx ===

import React from 'react';
import Toolbar from '../components/toolbar/Toolbar';
import SystemMenu from '../components/deviceMap/SystemMenu';
import MapFeature from '../features/map/MapFeature';
import Map from '../features/map/Map';

const MainPage: React.FC = () => {
  return (
    <div style={{ height: '100vh', width: '100vw', position: 'relative' }}>
      <Map></Map>
      <SystemMenu />
    </div>
  );
};

export default MainPage;


=== src/types/map.ts ===

import { DeviceType } from './devices';

export interface MapBase {
  mapType: MapType;
  showGrid: boolean;
  zoom: number;
  center: { lat: number; lng: number };
  devices: [];
  zones: [];
  visibleTypes: Record<DeviceType, boolean>;
  rulerMode: boolean;
}

export type MapType = 'google_satellite' | 'google_vector' | 'osm';


=== src/types/devices.ts ===

export interface Coordinates {
  lat: number;
  lng: number;
}

export enum ConnectionStatus {
  ONLINE = 'ONLINE',
  OFFLINE = 'OFFLINE',
  UNSTABLE = 'UNSTABLE',
  UPDATING = 'UPDATING',
}
export enum OperationStatus {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  STANDBY = 'STANDBY',
  FAULT = 'FAULT',
}

export interface DeviceBase {
  id: string;
  name: string;
  coordinates: Coordinates;
  connectionStatus: ConnectionStatus;
  operationStatus: OperationStatus;
  lastUpdated: string;
  batteryLevel: number;
  isMobile: boolean;
  vendor: string;
  firmwareVersion: string;
}

export enum DeviceType {
  JAMMER = 'JAMMER',
  DETECTOR = 'DETECTOR',
  SPOOFER = 'SPOOFER',
}

export enum JammerType {
  GSM = 'GSM',
  WiFi = 'WiFi',
  GPS = 'GPS',
  UAV = 'UAV',
}
export interface FrequencyRange {
  min: number;
  max: number;
}
export interface Jammer extends DeviceBase {
  type: DeviceType.JAMMER;
  jammerType: JammerType;
  frequencyRange: FrequencyRange;
  jammingPower: number;
  supportedProtocols: string[];
  autoShutdownTimeout: number;
  azimut: number;
  sector: number;
}

export enum ScanMode {
  FAST = 'FAST',
  DEEP = 'DEEP',
}
export interface Detector extends DeviceBase {
  type: DeviceType.DETECTOR;
  frequency: number;
  radius: { value: number; unit: string };
  sensitivity: number;
  scanMode: ScanMode;
  detectedSignals: { frequency: number; strength: number; type: string }[];
}

export enum SpoofingType {
  MEACONING = 'MEACONING',
  REPLAY = 'REPLAY',
  GENERATIVE = 'GENERATIVE',
}
export interface Spoofer extends DeviceBase {
  type: DeviceType.SPOOFER;
  transmitterPower: number;
  effectRadius: { value: number; unit: string };
  spoofingType: SpoofingType;
  frequencyRanges: FrequencyRange[];
  activeScenario: string;
  successRate: number;
}

export type Device = Jammer | Detector | Spoofer;

export interface Zone {
  id: string;
  center: Coordinates;
  radius: number;
}
export interface DeviceGroup {
  id: string;
  name: string;
  devices: Device[];
  zone: Zone;
}

