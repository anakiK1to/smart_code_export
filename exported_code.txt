
=== src/components/deviceMap/DeviceMarker.css ===

.device-marker {
  background: white;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  text-align: center;
  line-height: 24px;
  font-weight: bold;
}


=== src/components/deviceMap/DeviceMarker.tsx ===

import React from 'react';
import { Marker, Tooltip, Circle, Polygon } from 'react-leaflet';
import L from 'leaflet';
import {
  Device,
  Jammer,
  Detector,
  DeviceType,
  Spoofer,
} from '../../types/devices';

type Props = { device: Device };

const DeviceMarker: React.FC<Props> = ({ device }) => {
  const getBaseIcon = (color: string, letter: string) => {
    return new L.DivIcon({
      html: `
        <div style="
          width: 32px;
          height: 32px;
          background: ${color};
          border: 2px solid white;
          border-radius: 50%;
          display: flex;
          justify-content: center;
          align-items: center;
          color: white;
          font-weight: bold;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        ">
          ${letter}
        </div>
      `,
      className: '',
      iconSize: [32, 32],
      iconAnchor: [16, 16],
    });
  };

  const renderJammerComponents = (jammer: Jammer) => {
    const getSectorPoints = () => {
      const center = [jammer.coordinates.lat, jammer.coordinates.lng];
      const radius = jammer.jammingPower * 10;
      const startAngle = jammer.azimut - jammer.sector / 2;
      const endAngle = jammer.azimut + jammer.sector / 2;
      const points = [center];

      for (let angle = startAngle; angle <= endAngle; angle += 5) {
        const rad = (angle * Math.PI) / 180;
        const lat = center[0] + (radius / 111300) * Math.cos(rad);
        const lng =
          center[1] +
          (radius / (111300 * Math.cos((center[0] * Math.PI) / 180))) *
            Math.sin(rad);
        points.push([lat, lng]);
      }

      return points;
    };

    return (
      <>
        <Polygon
          positions={getSectorPoints()}
          color="red"
          fillColor="rgba(255, 0, 0, 0.2)"
          fillOpacity={0.5}
        />
      </>
    );
  };

  const renderDetectorComponents = (detector: Detector) => {
    const radiusInMeters =
      detector.radius.unit === 'km'
        ? detector.radius.value * 1000
        : detector.radius.value;

    return (
      <Circle
        center={[detector.coordinates.lat, detector.coordinates.lng]}
        radius={radiusInMeters}
        color="blue"
        fillColor="rgba(0, 0, 255, 0.2)"
        fillOpacity={0.5}
      />
    );
  };

  const renderSpooferComponents = (spoofer: Spoofer) => {
    const radiusInMeters =
      spoofer.effectRadius.unit === 'km'
        ? spoofer.effectRadius.value * 1000
        : spoofer.effectRadius.value;

    return (
      <>
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters * 0.3}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.3}
          stroke={true}
        />
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters * 0.6}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.2}
          stroke={true}
        />
        <Circle
          center={[spoofer.coordinates.lat, spoofer.coordinates.lng]}
          radius={radiusInMeters}
          color="#ff00ff"
          fillColor="rgba(255, 0, 255, 0.1)"
          fillOpacity={0.1}
          stroke={true}
        />
      </>
    );
  };

  const renderDeviceSpecificComponents = () => {
    switch (device.type) {
      case DeviceType.JAMMER:
        return renderJammerComponents(device as Jammer);
      case DeviceType.DETECTOR:
        return renderDetectorComponents(device as Detector);
      case DeviceType.SPOOFER:
        return renderSpooferComponents(device as Spoofer);
      default:
        return null;
    }
  };

  const getDeviceIcon = () => {
    switch (device.type) {
      case DeviceType.JAMMER:
        return getBaseIcon('#ff4444', 'J');
      case DeviceType.DETECTOR:
        return getBaseIcon('#4444ff', 'D');
      case DeviceType.SPOOFER:
        return getBaseIcon('#cc00cc', 'S');
      default:
        return getBaseIcon('#888888', '?');
    }
  };

  const renderTooltipContent = () => {
    return (
      <div style={{ padding: '4px', fontSize: '12px' }}>
        <strong>{device.name}</strong>
        <br />
        –¢–∏–ø: {device.type}
        <br />
        –°—Ç–∞—Ç—É—Å:{' '}
        <span
          style={{
            color: device.connectionStatus === 'ONLINE' ? 'green' : 'red',
          }}
        >
          {device.connectionStatus}
        </span>
        <br />
        –ë–∞—Ç–∞—Ä–µ—è: {device.batteryLevel}%
      </div>
    );
  };

  return (
    <>
      <Marker
        position={[device.coordinates.lat, device.coordinates.lng]}
        icon={getDeviceIcon()}
      >
        <Tooltip direction="top" offset={[0, -16]} opacity={1}>
          {renderTooltipContent()}
        </Tooltip>
      </Marker>
      {renderDeviceSpecificComponents()}
    </>
  );
};

export default DeviceMarker;


=== src/components/deviceMap/deviceMapSlice.ts ===

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Device, DeviceGroup, Zone, DeviceType } from '../../types/devices';

interface DeviceMapState {
  devices: Device[];
  groups: DeviceGroup[];
  zones: Zone[];
  visibleTypes: Record<DeviceType, boolean>;
}

const initialState: DeviceMapState = {
  devices: [],
  groups: [],
  zones: [],
  visibleTypes: { JAMMER: true, DETECTOR: true, SPOOFER: true },
};

export const deviceMapSlice = createSlice({
  name: 'deviceMap',
  initialState,
  reducers: {
    setDevices: (s, a: PayloadAction<Device[]>) => {
      s.devices = a.payload;
    },
    setGroups: (s, a: PayloadAction<DeviceGroup[]>) => {
      s.groups = a.payload;
    },
    setZones: (s, a: PayloadAction<Zone[]>) => {
      s.zones = a.payload;
    },
    toggleTypeVisibility: (s, a: PayloadAction<DeviceType>) => {
      s.visibleTypes[a.payload] = !s.visibleTypes[a.payload];
    },
  },
});

export const { setDevices, setGroups, setZones, toggleTypeVisibility } =
  deviceMapSlice.actions;
export default deviceMapSlice.reducer;


=== src/components/deviceMap/SystemMenu.css ===

.system-menu {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 10px;
  max-height: 40vh;
  overflow-y: auto;
  border-radius: 6px;
  z-index: 1000;
}
.device-info {
  margin-bottom: 8px;
  font-size: 0.9rem;
  line-height: 1.2;
}
.device-info strong {
  font-size: 1rem;
}
.system-menu label {
  display: block;
  margin-bottom: 4px;
  cursor: pointer;
}
.system-menu hr {
  border: 0;
  border-top: 1px solid rgba(255, 255, 255, 0.3);
  margin: 8px 0;
}


=== src/components/deviceMap/SystemMenu.tsx ===

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import './SystemMenu.css';
import { toggleType } from '../../redux/store/Store';

const SystemMenu: React.FC = () => {
  const dispatch = useDispatch();
  const { devices, visibleTypes } = useSelector((s: RootState) => s.app);

  return (
    <div className="system-menu">
      <h3>–°–∏—Å—Ç–µ–º–∞</h3>
      {Object.keys(visibleTypes).map((type) => (
        <label key={type}>
          <input
            type="checkbox"
            checked={visibleTypes[type as any]}
            onChange={() => dispatch(toggleType(type as any))}
          />
          {type}
        </label>
      ))}
      <hr />
      {devices.map((d) => (
        <div key={d.id} className="device-info">
          <strong>{d.name}</strong> [{d.type}]
          <div>
            Status: {d.connectionStatus}, Battery: {d.batteryLevel}%
          </div>
          <div>
            Coords: {d.coordinates.lat.toFixed(5)},{' '}
            {d.coordinates.lng.toFixed(5)}
          </div>
        </div>
      ))}
    </div>
  );
};

export default SystemMenu;


=== src/components/deviceMap/ZoneCircle.tsx ===

import React from 'react';
import { Circle } from 'react-leaflet';
import { Zone } from '../../types/devices';

type Props = { zone: Zone };

const ZoneCircle: React.FC<Props> = ({ zone }) => (
  <Circle
    center={[zone.center.lat, zone.center.lng]}
    radius={zone.radius}
    pathOptions={{ color: 'blue', fillOpacity: 0.1 }}
  />
);

export default ZoneCircle;


=== src/components/deviceMap/DeviceRadiusRuler.tsx ===

// src/components/deviceMap/DeviceRadiusRuler.tsx

import { Circle } from 'react-leaflet';
import { Coordinates } from '../../types/devices';

type Props = {
  center: Coordinates;
  radius: number;
};

export const DeviceRadiusRuler: React.FC<Props> = ({ center, radius }) => (
  <Circle
    center={[center.lat, center.lng]}
    radius={radius}
    pathOptions={{ dashArray: '4', color: 'orange' }}
  />
);


=== src/components/toolbar/Toolbar.tsx ===

/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import './Toolbar.css';
import { useSelector, useDispatch } from 'react-redux';
import { toggleRuler, zoomIn } from '../../redux/features/map/mapSlice';
import { useMap } from 'react-leaflet';

const Toolbar: React.FC = () => {
  const map = useMap();
  const dispatch = useDispatch();
  const mapType = useSelector((s: any) => s.app.mapType);
  const ruler = useSelector((s: any) => s.app.rulerMode);

  return (
    <div className="toolbar">
      <button onClick={() => map.zoomIn()}>+</button>
      <button onClick={() => map.zoomOut()}>‚Äì</button>
      {/* <button onClick={() => map.setView(map.getCenter(), 10)}>üéØ</button> */}
      <button onClick={() => dispatch(zoomIn())}>
        {mapType === 'osm' ? '–°–∞—Ç—Ç–µ–ª–∏—Ç' : 'OSM'}
      </button>
      {/* <button onClick={() => dispatch(zoomIn())}</button> */}
      <button
        className={ruler ? 'active' : ''}
        onClick={() => dispatch(toggleRuler())}
      >
        üìè
      </button>
    </div>
  );
};
export default Toolbar;


=== src/components/toolbar/Toolbar.css ===

.toolbar {
  position: absolute;
  top: 50%;
  left: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 1000;
}
.toolbar button {
  width: 36px;
  height: 36px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
.toolbar button.active {
  background: rgba(255, 255, 255, 0.8);
  color: black;
}


=== src/components/gridOverlayComponent/gridSlice.ts ===

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface GridState {
  step: number;
  color: string;
}

const initialState: GridState = {
  step: 10,
  color: 'rgba(0, 0, 0, 0.5)',
};

const gridSlice = createSlice({
  name: 'grid',
  initialState,
  reducers: {
    setStep: (state, action: PayloadAction<number>) => {
      state.step = action.payload;
    },
    setColor: (state, action: PayloadAction<string>) => {
      state.color = action.payload;
    },
  },
});

export const { setStep, setColor } = gridSlice.actions;
export default gridSlice.reducer;


=== src/components/gridOverlayComponent/GridOverlay.tsx ===

import React, { useEffect, useRef } from 'react';
import { useMap } from 'react-leaflet';

const GridOverlay: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const map = useMap();

  useEffect(() => {
    if (!map || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const drawGrid = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillStyle = 'color';
      ctx.font = '12px Arial';

      const gridSize = 100;

      for (let x = 0; x < canvas.width; x += gridSize) {
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.rect(x, y, gridSize, gridSize);
          ctx.stroke();
        }
      }

      const topLeft = map.containerPointToLatLng([0, 0]);
      const bottomRight = map.containerPointToLatLng([
        canvas.width,
        canvas.height,
      ]);

      const latStep =
        (topLeft.lat - bottomRight.lat) / (canvas.height / gridSize);
      const lngStep =
        (bottomRight.lng - topLeft.lng) / (canvas.width / gridSize);

      for (let x = 0; x < canvas.width; x += gridSize) {
        const lng = topLeft.lng + (x / gridSize) * lngStep;
        ctx.fillText(lng.toFixed(2), x + 5, 15);
      }

      for (let y = 0; y < canvas.height; y += gridSize) {
        const lat = topLeft.lat - (y / gridSize) * latStep;
        ctx.fillText(lat.toFixed(2), 5, y - 5);
      }
    };

    map.on('move', drawGrid);
    map.on('zoom', drawGrid);
    drawGrid();

    return () => {
      map.off('move', drawGrid);
      map.off('zoom', drawGrid);
    };
  }, [map]);

  return (
    <canvas
      ref={canvasRef}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: 1000,
        pointerEvents: 'none',
      }}
    />
  );
};

export default GridOverlay;

